import { ExportOptions } from '../export';

export interface CSVOptions {
    delimiter?: string;
    encoding?: string;
    includeHeaders?: boolean;
    quoteAll?: boolean;
    lineEnding?: '\r\n' | '\n';
    decimalSeparator?: string;
    dateFormat?: string;
}

export class CSVRenderer {
    private options: CSVOptions;

    constructor(options?: CSVOptions) {
        this.options = {
            delimiter: options?.delimiter || ',',
            encoding: options?.encoding || 'utf8',
            includeHeaders: options?.includeHeaders !== false,
            quoteAll: options?.quoteAll || false,
            lineEnding: options?.lineEnding || '\r\n',
            decimalSeparator: options?.decimalSeparator || '.',
            dateFormat: options?.dateFormat || 'YYYY-MM-DD HH:mm:ss'
        };
    }

    render(datasets: Record<string, any[]>, options?: ExportOptions): string {
        const results: string[] = [];

        // Add metadata as comments
        results.push(`# Report: ${options?.title || 'Report'}`);
        results.push(`# Generated: ${new Date().toISOString()}`);
        results.push(`# Generated By: ${options?.author || 'NOVA Framework'}`);
        
        if (options?.parameters) {
            results.push('# Parameters:');
            for (const [key, value] of Object.entries(options.parameters)) {
                results.push(`#   ${key}: ${JSON.stringify(value)}`);
            }
        }

        results.push('');

        // Render each dataset
        for (const [name, data] of Object.entries(datasets)) {
            if (data.length === 0) continue;

            results.push(`# Dataset: ${name}`);
            results.push(`# Rows: ${data.length}`);
            results.push('');

            // Get columns
            const columns = Object.keys(data[0]);

            // Headers
            if (this.options.includeHeaders) {
                const headerRow = columns
                    .map(col => this.escapeField(col, true))
                    .join(this.options.delimiter);
                results.push(headerRow);
            }

            // Data rows
            for (const row of data) {
                const rowValues = columns.map(col => {
                    const value = row[col];
                    return this.formatValue(value);
                });
                
                const rowString = rowValues
                    .map(val => this.escapeField(val, this.options.quoteAll))
                    .join(this.options.delimiter);
                
                results.push(rowString);
            }

            results.push(''); // Empty line between datasets
        }

        return results.join(this.options.lineEnding);
    }

    private formatValue(value: any): string {
        if (value === null || value === undefined) {
            return '';
        }

        if (value instanceof Date) {
            return this.formatDate(value);
        }

        if (typeof value === 'number') {
            return this.formatNumber(value);
        }

        if (typeof value === 'boolean') {
            return value ? 'Yes' : 'No';
        }

        if (typeof value === 'object') {
            return JSON.stringify(value);
        }

        return String(value);
    }

    private formatDate(date: Date): string {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');

        return this.options.dateFormat
            .replace('YYYY', year.toString())
            .replace('MM', month)
            .replace('DD', day)
            .replace('HH', hours)
            .replace('mm', minutes)
            .replace('ss', seconds);
    }

    private formatNumber(num: number): string {
        const numStr = num.toString();
        
        if (this.options.decimalSeparator !== '.') {
            return numStr.replace('.', this.options.decimalSeparator);
        }
        
        return numStr;
    }

    private escapeField(field: string, forceQuote: boolean = false): string {
        // Check if field needs quoting
        const needsQuote = forceQuote || 
            field.includes(this.options.delimiter) ||
            field.includes('"') ||
            field.includes('\n') ||
            field.includes('\r') ||
            field.startsWith(' ') ||
            field.endsWith(' ') ||
            field.startsWith('#') ||
            field === '';

        if (needsQuote) {
            // Escape quotes by doubling them
            return `"${field.replace(/"/g, '""')}"`;
        }

        return field;
    }

    renderSingleDataset(data: any[], options?: ExportOptions): string {
        return this.render({ 'Data': data }, options);
    }

    renderJSON(jsonData: any): string {
        if (Array.isArray(jsonData)) {
            return this.renderSingleDataset(jsonData);
        }
        
        if (typeof jsonData === 'object' && jsonData !== null) {
            return this.renderSingleDataset([jsonData]);
        }

        return '';
    }
}